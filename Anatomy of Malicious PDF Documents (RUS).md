# Анатомия вредоносных PDF-документов
**Дидьер Стивенс**
*Увеличение количества вредоносных PDF-документов породило интерес к способам анализа таких документов*

Эта статья научит вас анализировать конкретный класс вредоносных PDF-документов: те из них, которые используют уязвимость во встроенном интерпретаторе Java Script. Но помимо этого класса, полученные знания помогут вам с анализом и других классов документов, например, тех, в которых используется уязвимость PDF-парсера. Также, несмотря на тот факт, что большинство атак нацелено на ОС Windows, рассмотренные здесь проблемы равнозначно относятся и к документам, отрендеренным в других операционках, таких как Linux или OSX.

## Hello world в PDF
Давайте начнем с создания вручную самого простейшего PDF-документа из одной страницы с текстом "Hello world". Несмотря на то, что вы не найдете подобного документа в окружающем вас пространстве, для наших нужд он очень подходит: объяснит внутреннее строение PDF-документа. Он содержит только основные элементы, необходимые для отображения страницы, и отформатирован для лучшей читаемости. Одной из его особенностей является то, что он содержит только символы ANCII, что делает его читаемым в любом простейшем текстовом редакторе, таком как Блокнот. Другой его характеристикой является содержание большого количества лишних пробелов и отступов, добавленных для лучшей демонстрации структуры PDF. И наконец, содержимое его не было сжато.

### Заголовок
Каждый PDF-документ должен начинаться с одной строки, магической цифры, идентифицирующей файл как PDF-документ. Она так же определяет версию спецификации, используемую для расшифровки документа.
`%PDF-1.1`
Любая строка, начинающаяся с символа %, в документе является строкой комментария и её содержимое игнорируется за двумя исключениями:
Начало документа: %PDF-X.Y
Конец документа: %%EOF

### Объекты
Сразу за нашей первой строкой мы начинаем добавлять объекты (собранные из простейших элементов языка PDF) к нашему документу. Порядок, в котором эти объекты присутствуют в файле, не влияет на верстку страницы. Но для наглядности, мы будет представлять их в логическом порядке. Одна важная ремарка: язык PDF чувствителен к регистру. Наш первый объект - это каталог. Он говорит приложению, производящему рендеринг документа (такому как Adobe Acrobat Reader), где искать объекты, из которых собран документ.
```
1 0 obj
<<
 /Type /Catalog
 /Outlines 2 0 R
 /Pages 3 0 R
>>
endobj
```
Это, вообще-то, косвенный объект, поскольку имеет номер, на который можно ссылаться. Синтаксис прост: номер, версия, слово obj, непосредственно объект и слово endobj. Комбинация номера объекта и его версии позволяет уникально определять этот объект. Тип нашего первого объекта, каталога, - справочник. Справочники очень распространены в PDF-документах. Они начинаются со знака `<<` и заканчиваются знаком `>>`:
```
<<
    содержимое справочника
>>
```
Элементы в справочнике состоят из ключа и значения. Справочник может содержать элементы, объекты или другие справочники. Большинство словарей объявляют свой тип с помощью фразы `/Type (ключ)`, затем следует имя самого типа. В нашем случае, `/Catalog`.
```
/Type /Catalog
```
Объект "Catalog" должен содержать Аутлайны (рамки) и Страницы, имеющиеся в PDF.
```
 /Outlines 2 0 R
 /Pages 3 0 R
```
2 0 R и 3 0 R - это ссылки на косвенные объекты 2 и 3. Косвенный объект 2 описывает аутлайн, косвенный объект 3 описывает страницы.
Итак, давайте добавим второй косвенный объект в наш PDF-документ:
```
2 0 obj
<<
 /Type /Outlines
 /Count 0
>>
endobj
```
С учетом тех комментариев, которые сопровождали создание объекта 1, сейчас вы должны легко понять синтаксис создания второго объекта. Этот объект - справочник с типом `/Outlines`. Он имеет `/Count of 0`, что означает, что рамки для документа отсутствуют. На этот объект можно ссылаться используя его номер и версию: 2 и 0. 
Давайте подытожим, что у нас уже есть в PDF-документе: 
* строка, идентифицирующая PDF-документ
* косвенный объект 1
* косвенный объект 2
Перед тем, как мы будем добавлять страницу с текстом, давайте опишем другую особенность языка PDF. Наш объект каталога 1 ссылается на наш объект 2 
![Figure 1](/illustrations/pdf01.png) ![Figure 2](/illustrations/pdf02.png)

Язык PDF позволяет нам так же включать объект 2 непосредственно в объект 1, как указано на рисунке 2.
Тот факт, что объект рамки состоит из одной строки, не имеет значения с точки зрения семантики; так сделано исключительно для удобочитаемости.
Но давайте отложим эти лишние сведения и продолжим изучать наш PDF-документ.
Это должно быть достаточно ясно, за исключением, вероятно, элемента `/Kids`. Kids - это список страниц; список разделен квадратными скобками. Таким образом, согласно этому объекту Pages, в нашем документе только одна страница, косвенный объект 4 (отмеченная ссылкой 4 0 R)
```
3 0 obj
<<
 /Type /Pages
 /Kids [4 0 R]
 /Count 1
>>
endobj
```
Чтобы описать нашу страницу, мы должны понять, какие ресурсы используются для её рендеринга и расчета её размеров. Давайте попробуем:
```
4 0 obj
<<
 /Type /Page
 /Parent 3 0 R
 /MediaBox [0 0 612 792]
 /Contents 5 0 R
 /Resources <<
 /ProcSet [/PDF /Text]
 /Font << /F1 6 0 R >>
 >>
>>
endobj
```
Содержимое страницы определено в объекте 5. `/MediaBox` - это размер страницы. И еще одним ресурсом, используемым страницей, является шрифт и процедуры отрисовки текста. Мы определили один из шрифтов в косвенном объекте 6.
Контент страницы (объект 5) - это специальный тип объектов: потоковый объект. Потоковые объекты свое содержимое содержат между словами `stream` и `endstream`. Предназначение таких объектов: доступ к множеству типов кодирования (называемого фильтрами), таких как сжатие (иначе, zlib flatedecode). Но для читаемости, мы не будем включать сжатие в этот поток.
```
5 0 obj
<< /Length 43 >>
stream
BT /F1 24 Tf 100 700 Td (Hello World)
Tj ET
endstream
endobj
```
Содержимое этого потока представляет из себя набор инструкций для рендеринга текста. Эти инструкции разделены BT и ET, и по существу указывают рендеру делать следующее:
* используй шрифт F1 с размером 24
* перейди на позицию 100 700
* отрисуй текст "Hello world"

Строки в языке PDF заключены в круглые скобки. 
Мы почти завершили создание нашего PDF-документа. Последний объект, который нам нужен, это шрифт:
```
6 0 obj
<<
 /Type /Font
 /Subtype /Type1
 /Name /F1
 /BaseFont /Helvetica
 /Encoding /MacRomanEncoding
>>
endobj
```
Теперь у вас не должно возникнуть проблем с пониманием этой структуры.

### Трейлер
Теперь у нас есть все объекты для отрисовки страницы. Но этого не достаточно приложению (такому как Adobe Acrobat Reader), чтобы прочитать и отобразить наш документ. Отрисовщику нужно знать с какого объекта начинается описание документа `the (root object)`. А так же требуются некоторые технические детали, такие как порядковые номера каждого объекта. Порядковый номер объекта называется так же перекрестной ссылкой `href`, и описывается номером, версией и абсолютной позицией в файле каждого косвенного объекта. Первый индекс в PDF-документе должен начинаться со специального объекта 0 с версией 65535.
```
xref
0 7
0000000000 65535 f
0000000012 00000 n
0000000089 00000 n
0000000145 00000 n
0000000214 00000 n
0000000419 00000 n
0000000520 00000 n
```
Первое число после href - это номер первого косвенного объекта (в данном случае специального объекта 0). Второй номер - это размер xref-таблицы (7 записей).
Первая колонка - это абсолютная позиция косвенного объекта. Значение 12 во второй строке говорит, что косвенный объект 1 начинается с 12-го байта в файле. Вторая колонка это версия, и третья - сигнализирует, что объект используется (n) или свободен (f).
После перекрестной ссылки мы определяем корневой объект в трейлере. 
```
trailer
<<
 /Size 7
 /Root 1 0 R
>>
```
Мы опознали его, как словарь.
И наконец, нам нужно завершить PDF-документ абсолютной позицией элемента href и магического числа `%%EOF`:
```
startxref
644
%%EOF
```
644 - это абсолютная позиция href в файле.

## Обзор простейшего PDF-документа
Когда мы разобрались с основным синтаксисом и семантикой PDF, не так уж и трудно было создать простейший документ.
Расчет смещений объектов может быть достаточно утомительным, но в моем блоге есть несколько Python-программ, которые помогут с этим, кроме того большинство PDF-читалок способно справиться с ошибочным индексированием.

Для вашего изучения предлагаю полный листинг документа:

```
Listing 1. Complete PDF document
%PDF-1.1
1 0 obj
<<
 /Type /Catalog
 /Outlines 2 0 R
 /Pages 3 0 R
>>
endobj
2 0 obj
<<
 /Type /Outlines
 /Count 0
>>
endobj
3 0 obj
<<
 /Type /Pages
 /Kids [4 0 R]
 /Count 1
>>
endobj
4 0 obj
<<
 /Type /Page
 /Parent 3 0 R
 /MediaBox [0 0 612 792]
 /Contents 5 0 R
 /Resources <<
  /ProcSet [/PDF /Text]
  /Font << /F1 6 0 R >>
 >>
>>
endobj
5 0 obj
stream
 BT /F1 24 Tf 100 700 Td (Hello World) Tj ET
endstream
endobj
6 0 obj
<<
 /Type /Font
 /Subtype /Type1
 /Name /F1
 /BaseFont /Helvetica
 /Encoding /MacRomanEncoding
>>
endobj
xref
0 7
0000000000 65535 f
0000000012 00000 n
0000000089 00000 n
0000000145 00000 n
0000000214 00000 n
0000000419 00000 n
0000000520 00000 n
trailer
<<
 /Size 7
 /Root 1 0 R
>>
startxref
644
%%EOF
```

## Добавляем функционал
Поскольку мы хотим проанализировать вредоносные PDF-документы с функционалом на JavaScript, нам нужно понять, как мы можем добавить JavaScript и передать его на выполнение.
Язык PDF поддерживает ассоциацию действий с событиями. Например, когда показывается часть страницы, может быть выполенено связанное действие, например, посещение вебсайта.
Одно из таких действий, интересующее нас - открытие документа. Добавление ключа `/OpenAction` в каталог объектов позволит нам запустить выполнение какого-либо действия в момент открытия документа, при этом без дополнительных действий пользователя.
```
1 0 obj
<<
 /Type /Catalog
 /Outlines 2 0 R
 /Pages 3 0 R
 /OpenAction 7 0 R
>>
endobj
```
Действие, запускаемое при открытии PDF-документа, определено в объекте 7. Мы можем задать URI-action. URI-action автоматически открывает URI, в нашем случае - URL:
```
7 0 obj
<<
 /Type /Action
 /S /URI
 /URI (https://DidierStevens.com)
>>
endobj
```
Большинство PDF-читалок запустит браузер по-дефолту (в Windows - Internet Explorer), и перейдет по URL. Начиная с версии 7, Adobe Acrobat спросит пользовательскую авторизацию перед запуском браузера.

## Встроенный JavaScript
Язык PDF имеет встроенный JavaScript. Однако, движок очень ограничен в своем взаимодействии с Операционной системой, и практически непригоден для вредоносных целей. К примеру, встроенный в PDF JavaScript не может получить доступ к сторонним файлам. 
Вот почему вредоносные PDF-документы эксплуатируют уязвимости, позволяющие выполнить произвольных код и не ограничиваться возможностями движка JavaScript. 
Добавление JavaScript и его выполнение при открытии документа делается так:
```
7 0 obj
<<
 /Type /Action
 /S /JavaScript
 /JS (console.println("Hello"))
>>
endobj
```
Этот кусок запустит скрипт, который выведет 'Hello' в консоль JavaScript.
```
console.println("Hello")
```

## Эксплуатация уязвимостей
В прошлом году множество вредоносных PDF-документов эксплуатировали уязвимость в методе `util.printf`. Core Security
Technologies опубликовали отчет о следующем эксплоите:
```
var num = 12999999999999999999888888
.....
util.printf(„%45000f”,num)
```
Когда этот кусок встраивается в PDF-документ и запускается при открытии документа (Adobe Acrobat Reader 8.1.2 на Windows XP SP2), в резултате чего выдается ошибка `Access Violation at address 0x30303030`. Таким образом, мы понимаем, что переполняется некий буфер. Запуск эксплоита инициирует обращение к адресу 0x30303030  (0x30 это шестнадцатиричное представление ASCII-символа "0"). Поэтому, чтобы использовать эту уязвимость, нам нужно написать нашу программу (двоичный код) в адрес 0x30303030.
Проблема в том, что мы не можем писать непосредственно в память, если используем встроенный JavaScript. Heap spraying (запись набора байт в различные места памяти) часто использует некие "костыли". Каждый раз, когда мы объявляем строку в JavaScript, мы забираем кусок памяти, чтобы туда её записать. Этот кусок памяти называется кучей (heap). Мы не можем никак повлиять на то, какая часть памяти будет использована, поэтому мы не можем приказать JavaScript использовать память по адресу 0x30303030. Но если мы будем использовать большое количество строк, наши шансы возрастут, какая-нибудь строка может занять память по адресу 0x30303030. Вставка такого большого количества строк называется Head spraying. 
Если мы запустим эксплоит после подобного "забрызгивания кучи", существует значительная вероятность, что попадем в строку, начавшуюся где-то перед, и заканчивающуюся где-то после адреса 0x30303030. Таким образом те несколько байт нашей строчки, начиная с адреса 0x30303030, будут выполнены как машинный код процессором. 
И как же нам сделать так, чтобы та часть строки содержала нужные байты, способные передать управление нашему эксплоиту? Опять-таки, сделать это напрямую невозможно. Будем писать костыли.
Если мы создаим строку, которая может быть интерпретирована как машинный код, процессор обратится к ней по адресу 0x30303030. Но это не круто, наша программа должна начать выполнятся с её первой инструкции, а не откуда-то из середины. Для решения этой проблемы мы предварим первую инструкцию нашей программы очень длинным NOP-sled (однобайтовой инструкцией). Мы сохраним эту инструкцию в строке, которую используем в heap-spray. Однобайтовая инструкция NOP не выполняет никаких действий (NOP = No Operations), таким образом процессор будет выполнять большое количество NOP-инструкций, пока не дойдет до основного кода и не выполнит его.
Вот пример heap-spraying NOP-инструкций из реального вредоносного PDF-документа (рисунок 3).

![Figure 3](/illustrations/pdf03.png)

`Sccs` - строка с вредоносным кодом, `bgbl` - строка с NOP-кодом. 
Поскольку исполняемый код должен быть небольшим, он скачивает другую программу через сеть и запускает её. Но в случае с PDF может быть применен другой метод. Сторонняя программа может быть внедрена в тело документа, а машинный код извлекает её оттуда и запускает.

## Анализируя вредоносные PDF-документы

Практически все PDF-документы содержат не-ANCII символы, поэтому нам пригодится какой-нибудь hex-редактор для их анализа. Откроем подозрительный документ и поищем строку "JavaScript" (рисунок 4). 

![Figure 4](/illustrations/pdf04.png)

Хотя там мало пробелов, используемых для форматирования объекта, вы должны были распознать структуру PDF-объекта. Объект 31 - это JavaScript действие `/S /JavaScript`. Скрипт не присутствует в объекте, но может быть найден в объекте 32 (отмеченном ссылкой 32 0 R). Поискав строку 31 0 R, мы обнаружим, что объект 16 ссылается на объект 31 ```/AA <</O 31 0 R>>``` и является страницей `/Type /Page` (рисунок 5). 

![Figure 5](/illustrations/pdf05.png)

`/AA` - это действие при аннотации, что означает, что оно запустится при отображении страницы. Таким образом мы понимаем, что этот скрипт запустится при открытии PDF-документа. Давайте взглянем на скрипт в объекте 32.
Объект 32 потоковый, и он сжат (`/Filter [/FlateDecode]`, рисунок 6).

![Figure 6](/illustrations/pdf06.png)

Для разархивирования нам потребуется извлечь фрагмент двоичных данных (1154 байта) и разархивировать их простейшей программой на Perl или Python. На Python-е на нужно будет импортировать библиотеку zlib, и выполнить декомпрессию (предполагая, что наши бинарные данные загружены в data):
```
import zlib
decompressed = zlib.decompress(data)
```
Теперь понятно, что скрипт является вредоносным, он эксплуатирует уязвимость в функции collectEmailInfo (рисунок 7).

![Figure 7](/illustrations/pdf07.png)

Поскольку анализ документов при помощи hex-редакторов достаточно утомителен, я написал программу, помогающую проанализировать PDF-документ. Вы можете найти её в моем блоге http://blog.didierstevens.com/programs/pdftools/ вместе с инструкцией по использованию.

## Заключение

Анализ PDF-документов не так труден, когда вы понимается основные структуры PDF-документа. Поиск ключевых символов JavaScript, эксплуатирующего уязвимости, достаточно труден. Поэтому используйте автоматические инструменты.

> Источник: https://vulscan.googlecode.com/files/%5BHackin9%5D%20Anatomy%20of%20Malicious%20PDF%20Documents.pdf

> Переведено: 18.09.2015 (by effus)